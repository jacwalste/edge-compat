import { writeFile } from 'node:fs/promises';
import { relative } from 'pathe';
import type { Finding } from '@edge-compat/rules';
import { RuleSeverity } from '@edge-compat/rules';
import type { Reporter, ReporterOptions, ScanResult } from './types.js';

/**
 * Markdown reporter - generates edge-compat-report.md
 */
export class MarkdownReporter implements Reporter {
  async report(result: ScanResult, options: ReporterOptions): Promise<void> {
    const { findings, fileCount, duration } = result;
    const outputFile = options.outputFile || 'edge-compat-report.md';

    let md = '# Edge Compatibility Report\n\n';
    md += `**Generated:** ${new Date().toISOString()}\n\n`;
    md += `**Files Scanned:** ${fileCount}\n\n`;
    md += `**Duration:** ${duration.toFixed(2)}ms\n\n`;

    if (findings.length === 0) {
      md += '## ‚úÖ No Issues Found\n\n';
      md += 'All scanned files are compatible with Edge runtimes.\n';
    } else {
      // Summary
      const errors = findings.filter((f) => f.severity === RuleSeverity.ERROR);
      const warnings = findings.filter(
        (f) => f.severity === RuleSeverity.WARNING,
      );
      const info = findings.filter((f) => f.severity === RuleSeverity.INFO);

      md += '## Summary\n\n';
      md += '| Severity | Count |\n';
      md += '|----------|-------|\n';
      md += `| ‚ùå Errors | ${errors.length} |\n`;
      md += `| ‚ö†Ô∏è Warnings | ${warnings.length} |\n`;
      md += `| ‚ÑπÔ∏è Info | ${info.length} |\n\n`;

      // Group findings by rule
      const findingsByRule = new Map<string, Finding[]>();
      for (const finding of findings) {
        const existing = findingsByRule.get(finding.ruleId) || [];
        existing.push(finding);
        findingsByRule.set(finding.ruleId, existing);
      }

      md += '## Findings by Rule\n\n';

      for (const [ruleId, ruleFindings] of findingsByRule.entries()) {
        md += `### ${ruleId}\n\n`;
        md += `**Occurrences:** ${ruleFindings.length}\n\n`;

        for (const finding of ruleFindings) {
          const relPath = relative(options.cwd, finding.location.file);
          const location = `${relPath}:${finding.location.line}:${finding.location.column}`;

          md += `#### ${this.getSeverityBadge(finding.severity)} ${location}\n\n`;
          md += `${finding.message}\n\n`;

          if (finding.codeFrame) {
            md += '```\n';
            md += finding.codeFrame.code + '\n';
            md += '```\n\n';
          }

          if (finding.suggestions && finding.suggestions.length > 0) {
            md += '**Suggestions:**\n\n';
            for (const suggestion of finding.suggestions) {
              md += `- ${suggestion.message}\n`;
              if (suggestion.importStatement) {
                md += `  - Import: \`${suggestion.importStatement}\`\n`;
              }
              if (suggestion.package) {
                md += `  - Package: \`${suggestion.package}\`\n`;
              }
              if (suggestion.docsUrl) {
                md += `  - [Documentation](${suggestion.docsUrl})\n`;
              }
            }
            md += '\n';
          }
        }
      }
    }

    md += '---\n\n';
    md += '_Generated by [edge-compat](https://github.com/jackstepanek/edge-compat)_\n';

    await writeFile(outputFile, md, 'utf-8');
    console.log(`\nüìÑ Markdown report written to ${outputFile}`);
  }

  private getSeverityBadge(severity: RuleSeverity): string {
    switch (severity) {
      case RuleSeverity.ERROR:
        return '‚ùå Error';
      case RuleSeverity.WARNING:
        return '‚ö†Ô∏è Warning';
      case RuleSeverity.INFO:
        return '‚ÑπÔ∏è Info';
      default:
        return '';
    }
  }
}

